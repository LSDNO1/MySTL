# STL

## 目标：

### LeveL0：

使用C++标准库

### LeveL1：

认识C++标准库

### LeveL2:

良好使用C++标准库

### LeveL3：

扩充C++标准库

## STL六大部件

![屏幕截图 2023-06-20 103239](D:\C++\MySTL\屏幕截图 2023-06-20 103239.png)

### 容器

**容器在C++中的作用是提供了一种方便的方式来存储和管理数据**。它们可以帮助我们组织和操作数据，使得程序的开发更加高效和灵活。以下是容器的一些主要作用：

1. **存储数据**：容器可以存储不同类型的数据，如整数、浮点数、字符串等。它们提供了一种集中管理数据的方式，使得数据的访问和操作更加方便。

2. **管理数据结构**：容器提供了不同的数据结构，如数组、链表、栈、队列等。这些数据结构可以满足不同的需求，如快速查找、排序、插入和删除等操作。

3. **提供算法支持**：容器通常与算法库一起使用，可以方便地进行各种数据操作，如查找、排序、遍历等。标准库提供了丰富的算法函数，可以直接应用于容器中的数据。

4. **提高代码的可读性和可维护性**：使用容器可以使代码更加清晰和易于理解。容器提供了一些高级的数据操作接口，可以简化代码的编写，并减少错误的可能性。

5. **提高程序的性能**：容器的实现通常经过优化，可以提供高效的数据访问和操作。例如，向量（vector）提供了随机访问的能力，而链表（list）提供了高效的插入和删除操作。

总的来说，容器是C++中非常重要的工具，它们可以帮助我们更好地组织和处理数据，提高程序的效率和可维护性。

**前闭后开**空间，即*(c.end())不能识别

```C++
auto it=c.begin()
for(;it!=c.end();it++){};

//C++11之后的遍历容器
for(auto& it:num)
{
  std::cout<<it<<std::endl;  
};

for(int i:{1,2,3,4,5})
{
    std::cout<<i;
}
```

### 分配器

**分配器（Allocator）是C++中用于管理内存分配和释放的机制**。它**提供了一种抽象的方式来分配和释放内存，以及在容器中存储元素所需的内存管理**。

分配器的作用有以下几个方面：

1. **内存管理**：分配器负责为容器分配所需的内存空间。它可以跟踪已分配和未分配的内存块，并根据需要进行内存分配或释放。

2. **空间配置和释放**：分配器使用特定的策略来分配和释放内存空间。它可以通过调用 `allocate()` 方法来分配一块内存，而后通过调用 `deallocate()` 方法来释放已分配的内存。

3. **对象构造和析构**：分配器可以在已分配的内存上构造和析构对象。它通过 `construct()` 方法在已分配的内存上构造对象，并通过 `destroy()` 方法在释放内存之前析构对象。

4. **容器的内存重新分配**：当容器需要更大的内存空间时，分配器可以重新分配内存，并将容器中的元素从旧的内存复制到新的内存中。

5. **分配器的自定义**：通过自定义分配器，可以控制容器的内存分配策略。可以使用自定义分配器来满足特定的需求，如内存池、特定对齐需求等。

**使用分配器可以提供更灵活和可定制的内存管理方式**。**它使得容器能够根据需要动态地分配和释放内存，而不依赖于特定的内存分配策略**。此外，使用**自定义分配器**还可以**实现内存优化**、**性能优化**以及**特定环境下的内存管理需求**。

### 算法

**这些算法可以应用于各种容器类型或迭代器范围，而不依赖于具体的容器实现**。**它们与容器之间的关系是通过迭代器来实现的**。迭代器提供了对容器元素的访问和遍历功能，使算法能够操作容器的元素。

下面是算法和容器之间的关系：

1. **容器的迭代器范围**：算法通常接受容器的迭代器范围作为参数。这些范围由两个迭代器指定，分别是起始迭代器（begin）和结束迭代器（end）。例如，`std::sort(container.begin(), container.end())` 会对容器中的元素进行排序。

2. **迭代器的操作**：算法通过使用迭代器来访问容器的元素。它们可以使用解引用操作符 `*` 来获取迭代器指向的元素，或使用递增操作符 `++` 将迭代器移动到下一个位置。

3. **容器的特性**：算法并不依赖于容器的具体实现细节，而是通过迭代器提供了一种统一的访问方式。这意味着同一个算法可以适用于不同类型的容器，如向量、列表、数组等。

通过将算法与容器结合使用，可以实现各种功能，如搜索容器中的元素、对容器进行排序、对容器元素进行变换等。**这种分离算法和容器的设计使得代码更具灵活性和可重用性**。

### 迭代器

在C++中，迭代器与指针有着密切的关系。事实上，**迭代器可以被看作是一种抽象的指针**，用于访问容器中的元素。

以下是迭代器与指针之间的关系和相似之处：

1. **操作符重载**：迭代器与指针类似，可以使用类似于指针的操作符来访问元素，如 `*` 和 `->`。

2. **迭代器的分类**：与指针一样，迭代器也分为不同的类型，例如输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器，这些类型与指针的特性相对应。

3. **移动语义**：迭代器也可以通过递增或递减操作符来移动位置，就像指针可以通过加减整数来移动。

4. **数组与容器**：指针可以用于遍历数组元素，而迭代器则用于遍历容器（如 `std::vector`、`std::list` 等）中的元素。

然而，迭代器与指针也有一些不同之处：

1. **迭代器的抽象性**：迭代器提供了一种抽象的方式来访问容器元素，隐藏了底层容器的具体实现细节，而指针直接指向内存地址。

2. **迭代器的功能**：迭代器可以提供比指针更丰富的功能，如随机访问迭代器可以计算两个迭代器之间的距离。

3. **迭代器的适用范围**：指针主要用于原始数组和动态分配的内存，而迭代器适用于各种容器类型，包括数组、链表、向量等。

需要注意的是，迭代器和指针并不完全等同，虽然它们具有许多相似之处。在编程中，应根据需要选择使用指针或迭代器，并根据容器类型选择适当的迭代器来操作容器中的元素。

#### 关于auto在应用中的用法：

在实际应用中尽量减少auto的使用，正确写出类型能考验程序员水平，代码可读性更高

```C++
//
// Created by WLSD on 2023/6/20.
//
#include "stafix.h"

int main()
{
    int a[]={1,4,6,8,7,9,10};
    //                   默认分配器
    std::vector<int,std::allocator<int>>res(a,a+6);
	
    std::vector<int>::iterator it=res.begin();
	//it为指针
    for(it;it!=res.end();it++)
    {
        std::cout<<*it<<' ';
    }

    std::cout<<std::endl;
	//it为数组元素
    for(auto& it:res)
    {
        std::cout<<it<<' ';
    }

    return 0;
}

```

### 适配器

**适配器（Adapter）是一种设计模式，它用于将一个类的接口转换为另一个类的接口，以使得原本不兼容的类能够一起工作**。在C++中，**适配器也被广泛应用**于标准库中的**容器和算法之间**、**迭代器和算法**之间的**兼容性问题**。

适配器在C++中有几种常见的形式：

1. **容器适配器**：
   
   - `std::stack`：通过 `std::deque`、`std::list` 或 `std::vector` 等容器实现的堆栈（后进先出）数据结构。
   - `std::queue`：通过 `std::deque` 或 `std::list` 等容器实现的队列（先进先出）数据结构。
   - `std::priority_queue`：通过 `std::vector` 或 `std::deque` 等容器实现的优先队列。
   
   这些容器适配器在底层使用其他容器来实现不同的功能，提供了不同的接口来满足特定的需求。
   
2. **迭代器适配器**：
   
   - `std::reverse_iterator`：用于反向遍历容器元素的适配器。
   - `std::insert_iterator`：用于在容器中指定位置插入元素的适配器。
   - `std::back_insert_iterator`：用于在容器尾部插入元素的适配器。
   - `std::front_insert_iterator`：用于在容器头部插入元素的适配器。
   
   **这些适配器通过改变迭代器的行为，使其能够以不同的方式操作容器的元素**，例如逆向遍历、插入元素等。

**适配器的目的是提供一种转换层，使得原本不兼容的接口能够协同工作**。它们**通过封装和转换来适应不同的需求和接口规范**，使得不同组件之间的整合更加灵活和可扩展。**适配器模式可以提高代码的可重用性和可维护性，并促进组件之间的解耦**。

### 仿函数

**仿函数（Functor）是一种特殊的对象，它可以像函数一样被调用**。在C++中，仿函数是**通过重载函数调用运算符 `operator()` 来实现**的。仿函数可以用于实现函数对象，将其作为函数参数传递、在算法中使用，或者用作容器的排序准则等。

仿函数可以完成以下功能：

1. **封装函数行为**：通过实现函数调用运算符 `operator()`，可以将一系列操作封装为一个可调用的对象。这使得可以像调用函数一样调用仿函数对象。

2. **可定制行为**：通过定义自定义的仿函数，可以实现自定义的操作行为。可以根据需要定制参数、返回值以及处理逻辑。

3. **函数对象作为参数**：仿函数可以作为函数参数传递给其他函数，这使得能够以函数对象的方式向其他函数传递特定的行为。例如，在排序算法中，可以通过仿函数指定排序的准则。

4. **算法中的应用**：标准库中的许多算法接受仿函数作为参数，以便在算法中执行特定的操作或排序。例如，`std::sort()` 可以接受一个仿函数作为比较准则来排序容器中的元素。

**通过使用仿函数，可以将函数调用的灵活性和可定制性与面向对象的思想相结合，提供更灵活和可扩展的代码组织方式**。仿函数在C++中广泛应用于标准库算法、泛型编程以及其他需要定制行为的场景。

```C++
#include <iostream>
#include <vector>
#include <algorithm>

// 定义一个仿函数，用于比较两个整数的大小
struct Compare {
    bool operator()(int a, int b) const {
        // 按照从大到小的顺序进行排序
        return a > b;
    }
};

int main() {
    std::vector<int> numbers = {5, 2, 8, 3, 1};

    // 使用仿函数 Compare 来指定排序准则
    std::sort(numbers.begin(), numbers.end(), Compare());

    // 输出排序后的结果
    for (const auto& num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

```

### 六大部件之间的联系：

```C++
//
// Created by WLSD on 2023/6/20.
//
#include "stafix.h"

template<class T>
class Funtional
{
public:
    bool operator()(T a,T b )
    {
        return a>b;
    }
};

int main()
{
    int a[]={1,4,5,8,2,0,10};
    //                   默认分配器
    std::vector<int,std::allocator<int>>res(a,a+6);

    for(auto& num:res)
    {
        std::cout<<num<<' ';
    }
    std::cout<<std::endl;
    //通过迭代器来进行对容器内存的遍历
    std::vector<int>::iterator it_begin=res.begin();
    std::vector<int>::iterator it_end=res.end();
    //默认升序
    std::sort(it_begin,it_end);
    for(auto& num:res)
    {
        std::cout<<num<<' ';
    }
    std::cout<<std::endl;
    //实现降序,通过仿函数实现
    std::sort(it_begin,it_end,Funtional<int>());
    for(auto& num:res)
    {
        std::cout<<num<<' ';
    }
    std::cout<<std::endl;
    return 0;
}


```

### 头文件

```C++
//
// Created by WLSD on 2023/6/20.
//

#ifndef MYSTL_STAFIX_H
#define MYSTL_STAFIX_H
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>


#endif //MYSTL_STAFIX_H

```

